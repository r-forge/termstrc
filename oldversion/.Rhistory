jumppath(rnorm.pseudo(5000,30),M(-0.003,0.05,N(30,5000,15)))
jumppath(rnorm.pseudo(30,5000),M(-0.003,0.05,N(30,5000,15)))
rnorm.pseudo(3,10)
M(-0.003,0.05,N(3,10,15))
M(-0.003,0.05,N(3*10,15))
#generate possion random numbers#
N<-function(pathlength,mcsteps,lambda){#
	#
	pois=matrix(rpois(mcsteps*pathLength,lambda),ncol=mcSteps)#
	pois#
	}#
#
#generate normal distributed numbers subject to N#
M <- function(a,b,N,eps2) {#
	#
	path = a*N + b#
	#
	}#
#
#jump diffusion path#
jumppath <- function (eps,M) { #
	#
	path=(mu-sigma*sigma/2 )*delta.t + sigma*sqrt(delta.t)*eps + M#
	path#
		}
M
N
M(-0.003,0.05,N(3*10,15))
M(-0.003,0.05,N(3,10,15))
N<-function(pathlength,mcsteps,lambda){#
	#
	pois=matrix(rpois(mcsteps*pathlength,lambda),ncol=mcSteps)#
	pois#
	}#
#
#generate normal distributed numbers subject to N#
M <- function(a,b,N,eps2) {#
	#
	path = a*N + b#
	#
	}#
#
#jump diffusion path#
jumppath <- function (eps,M) { #
	#
	path=(mu-sigma*sigma/2 )*delta.t + sigma*sqrt(delta.t)*eps + M#
	path#
		}
M(-0.003,0.05,N(3,10,15))
N<-function(pathlength,mcsteps,lambda){#
	#
	pois=matrix(rpois(mcsteps*pathlength,lambda),ncol=mcsteps)#
	pois#
	}#
#
#generate normal distributed numbers subject to N#
M <- function(a,b,N,eps2) {#
	#
	path = a*N + b#
	#
	}#
#
#jump diffusion path#
jumppath <- function (eps,M) { #
	#
	path=(mu-sigma*sigma/2 )*delta.t + sigma*sqrt(delta.t)*eps + M#
	path#
		}
M(-0.003,0.05,N(3,10,15))
jumppath(rnorm.pseudo(30,5000),M(-0.003,0.05,N(30,5000,15)))
#generate possion random numbers#
N<-function(pathlength,mcsteps,lambda){#
	#
	pois=matrix(rpois(mcsteps*pathlength,lambda),ncol=mcsteps)#
	pois#
	}#
#
#generate normal distributed numbers subject to N#
M <- function(a,b,N,eps2) {#
	#
	path = a*N + b#
	#
	}#
#
#jump diffusion path#
jumppath <- function (eps,M,mu,sigma,deltat) { #
	#
	path=(mu-sigma*sigma/2 )*deltat + sigma*sqrt(deltat)*eps + M#
	path#
		}#
		#
#jumppath(t(rnorm.pseudo(10,10)),M(0.5,0.5,N(10,10,5*1/12)))#
#
#payoff asian aritmetic call or put#
aAsian<-function(path,Type,S,X,Time,r){#
	St<-mean(S*exp(cumsum(path)))#
	#
	if (TypeFlag =="c") payoff = exp(-r*Time)*max(St-X,0)#
	if (TypeFlag == "p") payoff = exp(-r*Time)*max(0,X-St)#
	#
	payoff	#
	}#
#
#Inputs Option#
optioncharac=list(Type="c",S=100,X=100,Time=1/12,sigma=0.4,r=0.1,mu=0.1)#
#
#Settings for McSimulation#
mcsettings=list(deltat=1/360,pathlength=30,mcsteps=5000,mcloops=50,#
				antithetic=FALSE,standardization=FALSE,trace=FALSE,#
											scrambling=2,seed=4711)#
											#
											#
#rnumbsetting = list (init=TRUE,inov1=normal,inov2=N,inov3=M)#
#
jumpsettings=list(a,b,lambda=15)#
#
pathgen=jumppath#
#
payofffunc=	aAsian								#
#
plotoption=TRUE		#
#
library(fOptions)#
#
MCOptionJD <- function (optioncharac=list(Type,S,X,Time,sigma,r,mu),#
						mcsettings=list(deltat,pathlength,mcsteps,mcloops,antithetic,standardization,trace,scrambling,seed),#
						#rnumbsetting = list (init=TRUE,inov1,inov2,inov3), #
						pathgen, #
						payofffunc,#
						jumpsettings=list(a,b,lambda)#
						#
						 ) {#
		#
		#
		#initialize ci and sim_payoff matrix#
		ci<-matrix(0,ncol=2,nrow=mcsettings$mcloops)#
		sim_price<-matrix(0,ncol=1,nrow=mcsettings$mcloops)				#
		#
		for (j in 1:mcsettings$mcloops) { #
						#
		#generate random numbers#
		#pathgen(inov1=(mcsteps,pathlength),M(-0.003,0.05,N(,1,15)))		#
		#
			#
		path<- pathgen(rnorm.pseudo(mcsettings$pathlength,mcsettings$mcsteps),#
						M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)),optionchara$mu,optioncharac$sigma,optioncharac$deltat)#
						#
		path<- jumppath(rnorm.pseudo(30,5000),M(-0.003,0.05,N(30,5000,15)))#
				#it<- mapply(function(i) aAsian(path[,i]),1:100)		#
		#
		#calculate payoff			#
		it<- mapply(function(i) payofffunc(path[,i],optioncharac$Type,optioncharac$S,optioncharac$X,optioncharac$Time,#
											optioncharac$r),#
                    1:mcsettings$mcsteps)					#
		#save result#
		ci_matrix[j,]<-c(mean(it)-1.96*sd(it)/sqrt(mcsettings$mcsteps),mean(it)+1.96*sd(it)/sqrt(mcsettings$mcsteps))#
		sim_price[j,]<-mean(it)		#
							#
							}#
		return=list(ci=ci_matrix,sim_price=sim_price)					#
							#
						}
MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
MCOptionJD <- function (optioncharac=list(Type,S,X,Time,sigma,r,mu),#
						mcsettings=list(deltat,pathlength,mcsteps,mcloops,antithetic,standardization,trace,scrambling,seed),#
						#rnumbsetting = list (init=TRUE,inov1,inov2,inov3), #
						pathgen, #
						payofffunc,#
						jumpsettings=list(a,b,lambda)#
						#
						 ) {#
		#
		#
		#initialize ci and sim_payoff matrix#
		ci<-matrix(0,ncol=2,nrow=mcsettings$mcloops)#
		sim_price<-matrix(0,ncol=1,nrow=mcsettings$mcloops)				#
		#
		for (j in 1:mcsettings$mcloops) { #
						#
		#generate random numbers#
		#pathgen(inov1=(mcsteps,pathlength),M(-0.003,0.05,N(,1,15)))		#
		#
			#
		path<- pathgen(rnorm.pseudo(mcsettings$pathlength,mcsettings$mcsteps),#
						M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)),optioncharac$mu,optioncharac$sigma,optioncharac$deltat)#
						#
		path<- jumppath(rnorm.pseudo(30,5000),M(-0.003,0.05,N(30,5000,15)))#
				#it<- mapply(function(i) aAsian(path[,i]),1:100)		#
		#
		#calculate payoff			#
		it<- mapply(function(i) payofffunc(path[,i],optioncharac$Type,optioncharac$S,optioncharac$X,optioncharac$Time,#
											optioncharac$r),#
                    1:mcsettings$mcsteps)					#
		#save result#
		ci_matrix[j,]<-c(mean(it)-1.96*sd(it)/sqrt(mcsettings$mcsteps),mean(it)+1.96*sd(it)/sqrt(mcsettings$mcsteps))#
		sim_price[j,]<-mean(it)		#
							#
							}#
		return=list(ci=ci_matrix,sim_price=sim_price)					#
							#
						}
MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
MCOptionJD <- function (optioncharac=list(Type,S,X,Time,sigma,r,mu),#
						mcsettings=list(deltat,pathlength,mcsteps,mcloops,antithetic,standardization,trace,scrambling,seed),#
						#rnumbsetting = list (init=TRUE,inov1,inov2,inov3), #
						pathgen, #
						payofffunc,#
						jumpsettings=list(a,b,lambda)#
						#
						 ) {#
		#
		#
		#initialize ci and sim_payoff matrix#
		ci<-matrix(0,ncol=2,nrow=mcsettings$mcloops)#
		sim_price<-matrix(0,ncol=1,nrow=mcsettings$mcloops)				#
		#
		for (j in 1:mcsettings$mcloops) { #
						#
		#generate random numbers#
		#pathgen(inov1=(mcsteps,pathlength),M(-0.003,0.05,N(,1,15)))		#
		#
			#
		path<- pathgen(rnorm.pseudo(mcsettings$pathlength,mcsettings$mcsteps),#
						M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)),optioncharac$mu,optioncharac$sigma,mcsettings$deltat)#
						#
		path<- jumppath(rnorm.pseudo(30,5000),M(-0.003,0.05,N(30,5000,15)))#
				#it<- mapply(function(i) aAsian(path[,i]),1:100)		#
		#
		#calculate payoff			#
		it<- mapply(function(i) payofffunc(path[,i],optioncharac$Type,optioncharac$S,optioncharac$X,optioncharac$Time,#
											optioncharac$r),#
                    1:mcsettings$mcsteps)					#
		#save result#
		ci_matrix[j,]<-c(mean(it)-1.96*sd(it)/sqrt(mcsettings$mcsteps),mean(it)+1.96*sd(it)/sqrt(mcsettings$mcsteps))#
		sim_price[j,]<-mean(it)		#
							#
							}#
		return=list(ci=ci_matrix,sim_price=sim_price)					#
							#
						}
MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
N
N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)
path<- pathgen(rnorm.pseudo(mcsettings$pathlength,mcsettings$mcsteps),#
						M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)),optioncharac$mu,optioncharac$sigma,mcsettings$deltat)
M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda))
N
a
b
jumpsettings=list(a=-0.003,b=0.05,lambda=15)
M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda))
MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
optioncharac$mu
path<- pathgen(rnorm.pseudo(mcsettings$pathlength,mcsettings$mcsteps),#
						M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)),optioncharac$mu,optioncharac$sigma,mcsettings$deltat)
path
it<- mapply(function(i) payofffunc(path[,i],optioncharac$Type,optioncharac$S,optioncharac$X,optioncharac$Time,#
											optioncharac$r),#
                    1:mcsettings$mcsteps)
it
mean(it)
c(mean(it)-1.96*sd(it)/sqrt(mcsettings$mcsteps),mean(it)+1.96*sd(it)/sqrt(mcsettings$mcsteps))
MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
MCOptionJD <- function (optioncharac=list(Type,S,X,Time,sigma,r,mu),#
						mcsettings=list(deltat,pathlength,mcsteps,mcloops,antithetic,standardization,trace,scrambling,seed),#
						#rnumbsetting = list (init=TRUE,inov1,inov2,inov3), #
						pathgen, #
						payofffunc,#
						jumpsettings=list(a,b,lambda)#
						#
						 ) {#
		#
		#
		#initialize ci and sim_payoff matrix#
		ci<-matrix(0,ncol=2,nrow=mcsettings$mcloops)#
		sim_price<-matrix(0,ncol=1,nrow=mcsettings$mcloops)				#
		#
		for (j in 1:mcsettings$mcloops) { #
						#
		#generate random numbers#
		#pathgen(inov1=(mcsteps,pathlength),M(-0.003,0.05,N(,1,15)))		#
		#
			#
		path<- pathgen(rnorm.pseudo(mcsettings$pathlength,mcsettings$mcsteps),#
						M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)),#
						mu=optioncharac$mu,optioncharac$sigma,mcsettings$deltat)#
						#
		#path<- jumppath(rnorm.pseudo(30,5000),M(-0.003,0.05,N(30,5000,15)))#
				#it<- mapply(function(i) aAsian(path[,i]),1:100)		#
		#
		#calculate payoff			#
		it<- mapply(function(i) payofffunc(path[,i],optioncharac$Type,optioncharac$S,optioncharac$X,optioncharac$Time,#
											optioncharac$r),#
                    1:mcsettings$mcsteps)#
                    #
                    					#
		#save result#
		ci_matrix[j,]<-c(mean(it)-1.96*sd(it)/sqrt(mcsettings$mcsteps),mean(it)+1.96*sd(it)/sqrt(mcsettings$mcsteps))#
		sim_price[j,]<-mean(it)		#
							#
							}#
		return=list(ci=ci_matrix,sim_price=sim_price)					#
							#
						}
MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
MCOptionJD <- function (optioncharac=list(Type,S,X,Time,sigma,r,mu),#
						mcsettings=list(deltat,pathlength,mcsteps,mcloops,antithetic,standardization,trace,scrambling,seed),#
						#rnumbsetting = list (init=TRUE,inov1,inov2,inov3), #
						pathgen, #
						payofffunc,#
						jumpsettings=list(a,b,lambda)#
						#
						 ) {#
		#
		#
		#initialize ci and sim_payoff matrix#
		ci<-matrix(0,ncol=2,nrow=mcsettings$mcloops)#
		sim_price<-matrix(0,ncol=1,nrow=mcsettings$mcloops)				#
		#
		for (j in 1:mcsettings$mcloops) { #
						#
		#generate random numbers#
		#pathgen(inov1=(mcsteps,pathlength),M(-0.003,0.05,N(,1,15)))		#
		#
			#
		path<- pathgen(rnorm.pseudo(mcsettings$pathlength,mcsettings$mcsteps),#
						M(jumpsettings$a,jumpsettings$b,N(mcsettings$pathlength,mcsettings$mcsteps,jumpsettings$lambda)),#
						mu=optioncharac$mu,optioncharac$sigma,mcsettings$deltat)#
						#
		#path<- jumppath(rnorm.pseudo(30,5000),M(-0.003,0.05,N(30,5000,15)))#
				#it<- mapply(function(i) aAsian(path[,i]),1:100)		#
		#
		#calculate payoff			#
		it<- mapply(function(i) payofffunc(path[,i],optioncharac$Type,optioncharac$S,optioncharac$X,optioncharac$Time,#
											optioncharac$r),#
                    1:mcsettings$mcsteps)#
                    #
                    					#
		#save result#
		ci[j,]<-c(mean(it)-1.96*sd(it)/sqrt(mcsettings$mcsteps),mean(it)+1.96*sd(it)/sqrt(mcsettings$mcsteps))#
		sim_price[j,]<-mean(it)		#
							#
							}#
		return=list(ci=ci,sim_price=sim_price)					#
							#
						}
MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
MCOptionJD$ci
MCOptionJD$sim_price
mysim<-MCOptionJD(optioncharac,mcsettings,pathgen,payofffunc,jumpsettings)
mysim
plot(mysim$sim_price)
plot(mysim$sim_price,type="l")
lines(mysim$ci)
plot(mysim$sim_price,type="l",ylim=c(min(mysim$ci),max(mysim$ci))
)
lines(mysim$ci[1])
lines(mysim$ci[,1])
lines(mysim$ci[,2])
plot(mysim$sim_price,type="l",ylim=c(min(mysim$ci),max(mysim$ci)))#
 lines(mysim$ci[,2],lty=2)
 plot(mysim$sim_price,type="l",ylim=c(min(mysim$ci),max(mysim$ci)))#
 lines(mysim$ci[,2],lty=2,col=red)#
  lines(mysim$ci[,1],lty=2,col=red)
 plot(mysim$sim_price,type="l",ylim=c(min(mysim$ci),max(mysim$ci)))#
 lines(mysim$ci[,2],lty=2,col="red")#
  lines(mysim$ci[,1],lty=2,col="red")
mean(mysim$sim)
mean(mysim$sim) +1.96*sd(mysim$sim)/sqrt(50)
  legend("bottomright",legend=(c("Simulated Price","confidence interval"),col=c("black","red"),lty=c(1,2))
  legend("bottomright",legend=c("Simulated Price","confidence interval"),col=c("black","red"),lty=c(1,2))
  legend("bottomright",legend=c("simulated option price"," 95% confidence interval"),col=c("black","red"),lty=c(1,2))
plot(mysim$sim_price,type="l",ylim=c(min(mysim$ci),max(mysim$ci)),xlab="MC Loops", ylab="Option Price")#
 lines(mysim$ci[,2],lty=2,col="red")#
  lines(mysim$ci[,1],lty=2,col="red") 		#
  legend("bottomright",legend=c("simulated option price"," 95% confidence interval"),col=c("black","red"),lty=c(1,2))
j<-jumppath(rnorm.pseudo(100,1),M(-0.003,0.05,N(100,1,15)))#
plot(0:100,c(S,exp(log(S)+j)),type="l",ylim=c(80,120))	#
lines(0:100,c(S,S*exp(wienerpath(rnorm(10*10)))),col="red")
plot(cumsum(myres$sim_price)/(1:nrow(myssim$sim_price),type="l",xlab= "MC Loops",ylab="Option Price")
plot(cumsum(myres$sim_price)/(1:nrow(myssim$sim_price)),type="l",xlab= "MC Loops",ylab="Option Price")
plot(cumsum(mysim$sim_price)/(1:nrow(mysim$sim_price)),type="l",xlab= "MC Loops",ylab="Option Price")
jumpsettings
optioncharac
mcsettings
j<- jumppath(rnorm.pseudo(30,1),M(-0.03,0.05,N(30,1,15)),0.1,0.4,0.002777778)
j
j<- jumppath(rnorm.pseudo(30,1),M(-0.003,0.05,N(30,1,15)),0.1,0.4,0.002777778)
j
sum(j>0)
plot(0:100,c(100,exp(log(100)+j)),type="l",ylim=c(80,120))
plot(0:30,c(100,exp(log(100)+j)),type="l",ylim=c(80,120))
wienerpath
lines(0:30,c(100,100*exp(wienerpath(rnorm(30*1)))),col="red")
lines(0:30,c(100,100*exp(wienerpath(rnorm(1*30)))),col="red")
wienerpath
gbmpath <- function(eps,sigma,deltat,mu) {#
	#
	path=(mu-sigma*sigma/2 )*deltat + sigma*sqrt(deltat)*eps#
	path#
	#
	}
g<- gbmpath(rnorm.pseudo(30,1),0.4,0.0027777778,0.1)
g
plot(0:30,c(100,exp(log(100)+j)),type="l",ylim=c(80,120))	#
lines(0:30,c(100,100*exp(g),col="red")
)
plot(0:30,c(100,exp(log(100)+j)),type="l",ylim=c(80,120))
	#
lines(0:30,c(100,100*exp(g)),col="red")
j<- jumppath(rnorm.pseudo(3000,1),M(-0.003,0.05,N(3000,1,15)),0.1,0.4,0.002777778)#
g<- gbmpath(rnorm.pseudo(3000,1),0.4,0.0027777778,0.1)#
#
#
plot(0:3000,c(100,exp(log(100)+j)),type="l",ylim=c(80,120))	#
lines(0:3000,c(100,100*exp(g)),col="red")
c(var(j),var(g))
j<- jumppath(rnorm.pseudo(100,1),M(-0.003,0.05,N(100,1,15)),0.1,0.4,0.002777778)#
g<- gbmpath(rnorm.pseudo(100,1),0.4,0.0027777778,0.1)#
#
#
plot(0:100,c(100,exp(log(100)+j)),type="l",ylim=c(80,120))	#
lines(0:100,c(100,100*exp(g)),col="red")
plot(0:100,c(100,exp(log(100)+j)),type="l",ylim=c(95,105))	#
lines(0:100,c(100,100*exp(g)),col="red")
plot(0:100,c(100,exp(log(100)+j)),type="l",ylim=c(90,110))	#
lines(0:100,c(100,100*exp(g)),col="red")
plot(0:100,c(100,exp(log(100)+j)),type="l",ylim=c(90,110),ylab="Price Path", xlab="")	#
lines(0:100,c(100,100*exp(g)),col="red")#
legend("bottomright",legend=c("Jump Diffusion Price Path","Geometric Brownian Motion Price Path"),col=c("black","red"),lty=c(1,1))
n)-0.00245
n=-0.00245
n
(0.014^2 + n^2)/(2*0.024^2) + n/(2*0.024)
1-(0.014^2+0.0024^2)/0.024^2
1-(0.014^2+n^2)/0.024^2
n=-0.000021
(0.014^2 + n^2)/(2*0.024^2) + n/(2*0.024)
n=-0.00002
(0.014^2 + n^2)/(2*0.024^2) + n/(2*0.024)
2*3^3
2*(3^39
2*(3^3)
(0.014^2 + n^2)/(2*0.024^2) + n/(2*0.024)
n=-0.00002
1-(0.014^2+n^2)/0.024^2
0.1697+0.659
1-(0.1697+0.659)
1/6
2/3 - 0.1^2
1/6
4/6
1/6 -0.1/2
1/6 + (0.1^2*2^2-0.1*2)/2
(0.014^2+0.00101^2)/(2*0.0242^2) + 0.00101/2*0.0242
1/6
(0.014+0.0101^2)/2*0.0242^2 # 0.0101/2*0.024
(0.014+0.0101^2)/(2*0.0242^2) # 0.0101/(2*0.024)
0.01*100
(0.014^2+0.0101^2)/(2*0.0242^2) # 0.0101/(2*0.024)
(0.014^2+0.0101^2)/(2*0.0242^2) + 0.0101/(2*0.024)
library("termstrc")
demo(package="termstrc")
demo("corp01")
demo(package="termstrcFinal")
demo(package="termstrcFINAL")
demo("corp01")
str(eurobonds)
str(eurobond)
str(eurbond)
ls()
str(corpbonds)
23.520/14
23520/14
library("termstrcFINAL")
demo(euro01)
plot(myres)
library("termstrcFINAL")
demo(package="termstrcFINAL")
demo(demo01)
demo(euro01)
library("termsstrc")
library("termstrc")
demo(package="termstrc")
demo(euro01)
eurobonds
library("shortrate")
demo(package="shortrate")
demo("HW")
library("termstrcFinal")
library("termstrcFINAL")
demo(package="termstrcFINAL")
23660/14
26289.30/14
exp(-0.01*(1000*50))
exp(-0.01*(10000*50))
-exp(-0.01*(10000*50))
-exp(-0.01*(1000*50))
-exp(-0.01*(1*50))
-exp(-0.01*(-10000*50))
-exp(-0.01*(-10000*50)*50000)
-exp(-0.01*(-10000*50)*1/50000)
-exp(-0.01*(-10000*50*1/50000))
help(warning)
library(termstrc)
demo(package="termstrc")
demo(corp01)
demo(corp02)
help(nlminb)
library(termstrFINAL)
library(termstrFinal)
library(termstrcFinal)
library(termstrcFINAL)
demo(euro01)
setwd(/Users/macjoe/Desktop/termstrc/termstrc/R)
setwd("/Users/macjoe/Desktop/termstrc/termstrc/R")
load("eurobonds.RData")
source("svensson.r")
source("tools.r")
source("euro01.r")
cf[[1]]
apply(cf[[1]],2,sum)
sum(apply(cf[[1]],2,sum))
sum(apply(m[[1]],2,sum))
sum(apply(cf_p[[1]],2,sum))
sum(apply(cf_p[[1]],2,sum))
sum(apply(m_p[[1]],2,sum))
yields
sum(yields[[1]][,2])
sum(yields[[2]][,2])
sum(yields[[3]][,2])
duration
sum(duration[[3]][,3])
sum(duration[[1]][,3])
sum(duration[[2]][,3])
estimatedprices
estimated_prices
b
bond_prices(method,b[1,],m[[1]],cf[[1]])
Q
source("svensson.r")
source("euro01.r")
spot_rates
ls()
spotrates
Q
source("svensson.r")
source("euro01.r")
source("euro01.r")
ls()
ls()
source("euro01")
getwd()
source("euro01.R")
ls()
getwd()
source("euro01.R")
spot_rates
beta
sum(beta)
m
cf
method
nelson_siegel(m,b)
nelson_siegel(b[1,],m)
nelson_siegel
nelson_siegel(c(1,1,1,1,),1)
nelson_siegel(c(1,1,1,1),1)
nelson_siegel(c(1,1,1,1),0)
nelson_siegel(c(1,0,0,0),1)
nelson_siegel(c(0,1,0,0),1)
nelson_siegel(c(0,0,1,0),1)
Q
nelson_siegel <-#
  function(beta, m, curve="spotrate") {#
#
  switch(curve,#
  spotrate = beta[1] + beta[2] * ((1-exp(-m/beta[4]))/(m/beta[4]))#
             + beta[3]*(((1-exp(-m/beta[4]))/(m/beta[4]))#
             -exp(-m/beta[4])),#
  forwardrate = beta[1]+beta[2]*exp(-m/beta[4])+beta[3]*(m/beta[4])#
                *exp(-m/beta[4]),#
  creditspread = beta[1] + beta[2] * ((1-exp(-m/beta[4]))/(m/beta[4]))#
             + beta[3]*exp(-m/beta[4])             #
 )                    #
}
nelson_siegel(c(1,1,1,1),1)
nelson_siegel <-#
  function(beta, m) {#
#
 beta[1] + beta[2] * ((1-exp(-m/beta[4]))/(m/beta[4]))#
             + beta[3]*(((1-exp(-m/beta[4]))/(m/beta[4]))#
             -exp(-m/beta[4]))#
  }
nelson_siegel(c(1,1,1,1),1)
nelson_siegel <- function(beta, m) {#
#
 beta[1] + beta[2] * ((1-exp(-m/beta[4]))/(m/beta[4]))#
             + beta[3]*(((1-exp(-m/beta[4]))/(m/beta[4]))#
             -exp(-m/beta[4]))#
  }
nelson_siegel(c(1,1,1,1),1)
nelson_siegel <- function(beta, m) {#
#
 (beta[1] + beta[2] * ((1-exp(-m/beta[4]))/(m/beta[4]))#
             + beta[3]*(((1-exp(-m/beta[4]))/(m/beta[4]))#
             -exp(-m/beta[4])))#
  }
nelson_siegel(c(1,1,1,1),1)
source("euro01.R")
myres$opt_result
myres$opt_result
plot(myres)
