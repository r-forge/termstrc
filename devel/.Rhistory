install.packages("Rcpp)
")
install.packages("Rcpp")
install.packages("inline")
ls()
print(funx(0, 5))
    ## turn into a function that R can call
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway
    funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl/gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/usr/include",
                      libargs="-lgsl -lgslcblas")
    ## turn into a function that R can call
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway
    funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl/gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/usr/include",
                      libargs="-lgsl -lgslcblas")
    print(funx(0, 5))
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway
    funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl/gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/opt/local/include",
                      libargs="-lgsl -lgslcblas")
library("Rcpp")
library("inline")

## now use Rcpp to pass down a parameter for the seed, and a vector size
    gslrng <- '
       int seed = RcppSexp(s).asInt();
       int len = RcppSexp(n).asInt();

       gsl_rng *r;
       gsl_rng_env_setup();
       std::vector<double> v(len);

       r = gsl_rng_alloc (gsl_rng_default);

       gsl_rng_set (r, (unsigned long) seed);
       for (int i=0; i<len; i++) {
           v[i] = gsl_rng_get (r);
       }
       gsl_rng_free(r);

       return RcppSexp(v).asSexp();
    '
gslrng
 funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl/gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/opt/local/include",
                      libargs="-lgsl -lgslcblas")
    funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/opt/local/include/gsl",
                      libargs="-lgsl -lgslcblas")
   funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl/gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/opt/local/include/gsl",
                      libargs="-lgsl -lgslcblas")
funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl/gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/opt/local/include/",
                      libargs="-lgsl -lgslcblas")
## now use Rcpp to pass down a parameter for the seed, and a vector size
    gslrng <- '
       int seed = RcppSEXP(s).asInt();
       int len = RcppSEXP(n).asInt();

       gsl_rng *r;
       gsl_rng_env_setup();
       std::vector<double> v(len);

       r = gsl_rng_alloc (gsl_rng_default);

       gsl_rng_set (r, (unsigned long) seed);
       for (int i=0; i<len; i++) {
           v[i] = gsl_rng_get (r);
       }
       gsl_rng_free(r);

       return RcppSexp(v).asSexp();
    '

    ## turn into a function that R can call
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway
    funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes="#include <gsl/gsl_rng.h>",
                      Rcpp=TRUE,
                      cppargs="-I/opt/local/include/",
                      libargs="-lgsl -lgslcblas")
    ## now use Rcpp to pass down a parameter for the seed, and a vector size
    gslrng <- '
    int seed = wrap(s).asInt();
    int len = wrap(n).asInt();

    gsl_rng *r;
    gsl_rng_env_setup();
    std::vector<double> v(len);

    r = gsl_rng_alloc (gsl_rng_default);

    gsl_rng_set (r, (unsigned long) seed);
    for (int i=0; i<len; i++) {
       v[i] = gsl_rng_get (r);
    }
    gsl_rng_free(r);

    return wrap(v);
    '

    ## turn into a function that R can call
    ## compileargs redundant on Debian/Ubuntu as gsl headers are found anyway
    ## use additional define for compile to suppress output
    funx <- cfunction(signature(s="numeric", n="numeric"),
                      gslrng,
                      includes=c("#include <gsl/gsl_rng.h>",
                                 "using namespace Rcpp;",
                                 "using namespace std;"),
                      Rcpp=TRUE,
                      cppargs="-I/opt/local/include",
                      libargs="-lgsl -lgslcblas")
    cat("\n\nCalling fourth example with seed, length and namespaces\n")
suppressMessages(library(Rcpp))
suppressMessages(library(inline))

foo <- '
  SEXP  rl = R_NilValue;        // Use this when there is nothing to be returned.
  char* exceptionMesg = NULL;   // msg var in case of error

  try {
    RcppVector<int> vec(v);     // vec parameter viewed as vector of ints.
    int n = vec.size(), i = 0;
    if (n != 10000) throw std::length_error("Wrong vector size");
    for (int a = 0; a < 9; a++)
      for (int b = 0; b < 9; b++)
        for (int c = 0; c < 9; c++)
          for (int d = 0; d < 9; d++)
            vec(i++) = a*b - c*d;

    RcppResultSet rs;           // Build result set to be returned as a list to R.
    rs.add("vec", vec);         // vec as named element with name "vec"
    rl = rs.getReturnList();    // Get the list to be returned to R.
  } catch(std::exception& ex) {
    exceptionMesg = copyMessageToR(ex.what());
  } catch(...) {
    exceptionMesg = copyMessageToR("unknown reason");
  }

  if (exceptionMesg != NULL) Rf_error(exceptionMesg);

  return rl;
'

funx <- cfunction(signature(v="numeric"), foo, Rcpp=TRUE)

dd.inline.rcpp <- function() {
    x <- integer(10000)
    res <- funx(v=x)[[1]]
    tabulate(res)
}

print(mean(replicate(100,system.time(dd.inline.rcpp())["elapsed"]),trim=0.05))
foo <- '
  SEXP  rl = R_NilValue;        // Use this when there is nothing to be returned.
  char* exceptionMesg = NULL;   // msg var in case of error

  try {
    RcppVector<int> vec(v);     // vec parameter viewed as vector of ints.
    int n = vec.size(), i = 0;
    if (n != 10000) throw std::length_error("Wrong vector size");
    for (int a = 0; a < 9; a++)
      for (int b = 0; b < 9; b++)
        for (int c = 0; c < 9; c++)
          for (int d = 0; d < 9; d++)
            vec(i++) = a*b - c*d;

    RcppResultSet rs;           // Build result set to be returned as a list to R.
    rs.add("vec", vec);         // vec as named element with name "vec"
    rl = rs.getReturnList();    // Get the list to be returned to R.
  } catch(std::exception& ex) {
    exceptionMesg = copyMessageToR(ex.what());
  } catch(...) {
    exceptionMesg = copyMessageToR("unknown reason");
  }

  if (exceptionMesg != NULL) Rf_error(exceptionMesg);

  return rl;
'

funx <- cfunction(signature(v="numeric"), foo, Rcpp=TRUE)

dd.inline.rcpp <- function() {
    x <- integer(10000)
    res <- funx(v=x)[[1]]
    tabulate(res)
}

print(mean(replicate(100,system.time(dd.inline.rcpp())["elapsed"]),trim=0.05))
funx
foo <- '
	RcppVectorView<int> v(x);
	Rprintf( "RcppVectorView: n = %d \\n", v.size()) ;
	Rprintf( "RcppVectorView: elem 1 = %d \\n", v(1)) ;
        '
funx <- cfunction(signature(x="numeric"), foo, Rcpp=TRUE, verbose=FALSE)
x <- 1:9
funx(x=x)
foo <- '
	RcppMatrix<int> v(x);
	Rprintf( "RcppMatrix: n = %d times k= %d\\n", v.rows(), v.cols() ) ;
	Rprintf( "RcppMatrix: elem(1,2) = %d\\n", v(1,2) ) ;
        '
funx <- cfunction(signature(x="numeric"), foo, Rcpp=TRUE, verbose=FALSE)
x <- matrix(1:9, ncol=3)
funx(x=x)
1
